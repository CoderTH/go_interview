# TCP相关
## 一、TCP报文格式
![](https://gitee.com/coderth/blogimage/raw/master/img/20210418205850.png)
上图中tcp报文中每个字段含义如下

**源端口和目的端口字段**

* TCP源端口（Source Port）：源计算机上的应用程序的端口号，占 16 位。
* TCP目的端口（Destination Port）：目标计算机的应用程序端口号，占 16 位
  
**序列号字段**

CP序列号（Sequence Number）：占 32 位。它表示本报文段所发送数据的第一个字节的编号。在 TCP 连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号；如果SYN的值是1时，这个字段的值就是初始序列值（ISN），用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。（因为tcp会将数据分段进行传输，并将每一个报文段编号用于数据的重组以及同步，而这里的编号就是当前报文段的编号）

**确认号字段**

TCP 确认号（Acknowledgment Number，ACK Number）：占 32 位。它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个接收到的字节的序列号加1。（这里的ack其实就是三次握手图中那个小写的ack代表接受的下一个报文段的标号）

**数据偏移字段**

TCP 首部长度（Header Length）：数据偏移是指数据段中的“数据”部分起始处距离 TCP 数据段起始处的字节偏移量，占 4 位。其实这里的“数据偏移”也是在确定 TCP 数据段头部分的长度，告诉接收端的应用程序，数据从何处开始。

**保留（Reserved**

占 4 位。为 TCP 将来的发展预留空间，目前必须全部为 0。

**标识位字段**

* CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。
* ECE（ECN Echo）：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。
* URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。
* ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。
* PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。
* RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。
* SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。
* FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。

**窗口大小字段**

窗口大小（Window Size）：占 16 位。它表示从 Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。

**TCP校验字段**

校验位（TCP Checksum）：占 16 位。它用于确认传输的数据是否有损坏。发送端基于数据内容校验生成一个数值，接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。如果两个值不同，则丢掉这个数据包。Checksum 是根据伪头 + TCP 头 + TCP 数据三部分进行计算的。

**紧急指针字段**

紧急指针（Urgent Pointer）：仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据的字节数，占 16 位。当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存。（类似一个权重，设置了URG后这个数据将会有限得到处理）

## 二、TCP与UDP的区别

**TCP与UDP的基本区别**

* 基于连接与无连接
* TCP要求系统资源较多，UDP少
* UDP程序结构较为简单
* 流模式（TCP）与数据报模式（UDP）
* TCP保证数据正确性，UDP有可能会丢包
* TCP保证数据顺序，UDP不保证

**UDP应用的场景**

* 面向数据报方式
* 网络数据大多为短消息
* 拥有大量的client
* 对数据安全性无特殊的要求
* 网络负载非常重，但是对相应速度比较高

**为什么说TCP可靠**

1、ACK和超时重传
TCP首先会按照顺序给发送的数据标上号码。TCP每发送一个数据报，都会期待一个接收端ACK的回复，我们就知道接收端已经收到消息了。如果短时间内没有收到ACK，那么TCP就会对消息进行自动重发。
未收到ACK就说明消息一定就丢了吗？也不一定，有可能接收端收到消息了，返回ACK的途中发生了丢失。这个时候这个时候依然会进行超时重发。接收端可能会收到同样的消息，没关系我们不是对发送的数据进行编号了吗，如果接收端收到重复消息直接丢失就可以了。
2、流量控制
3、拥塞控制
4、TCP校验和，当tcp接受端收到数据后会将数据与tcp首部进行校验和，这是一个端到端的校验，如果发现数据有问题将会丢弃这个数据，并且不予以发送端ACK，让发送端触发超时重传机制。（为的就是检测报文段中的数据是否有过变动）


**滑动窗口具体是如何实现的呢？**

 tcp通过ACK与超时重传机制实现了可靠传输，但是一个数据段发送成功需要一个来回，然后再进行下一个数据段的发送，这样的效率太低了，我们可以批量化的将数据发送出去，而滑动窗口做的就是这件事情。
 在假设我们有一个http报文被分成了9组发送1、2、3、4、5、6、7、8、9。如果按照刚刚的逻辑来看，肯定先发送1。当1确认了之后再发送2以此类推
![](https://gitee.com/coderth/blogimage/raw/master/img/20210418213356.png)
这时候我们限定滑动窗口的大小为5，就规定了滑动窗口覆盖这个范围1~5的数据可以并行发送出去

![](https://gitee.com/coderth/blogimage/raw/master/img/20210418213422.png)

如果这时候接收端收到了1，并且返回了1的ACK，这时候窗口就会滑动一下，这时候6又可以被发送了.

![](https://gitee.com/coderth/blogimage/raw/master/img/20210418213458.png)

当然接收方也可以进行累计确认，并不一定对每个分组都发送ACK。假设接收方收到了1、2、3这3个分组，接收方只需要对分组3进行确认。这时候发送方收到了3的ACK，就代表3之前的数据你都已经收到了，我就将窗口移动到4。

![](https://gitee.com/coderth/blogimage/raw/master/img/20210418213534.png)

当然滑动窗口也有不足的地方，如果接收方收到分组1，2，4，5的数据而分组3丢失了，那么这时候只能返回分组2的ACK。4，5不能返回。因为如果一旦返回了4或5就代表4或5之前的数据我都已经收到了。当然发送发需要重新发送3、4、5。

TCP的窗口分为发送窗口和接受窗口，发送窗口的大小由接受端的能力决定。一般接收端报文确认的时候，会在TCP首部设置窗口大小。发送端接收到了确认会调整自己发送端涌口的大小，直到发送窗口的大小变为0就会暂停发送数据。这种发送暂停的状态会持续到发送端发送一个新的窗口值为止。

为什么要调整窗口呢？首先发送窗口是根据接收方的接收能力来决定的，假设一些数据已经到了接收端缓存，但是应用程序一直还没来得及获取，那么这时候就需要不断缩小窗口，不然发送端一直傻傻等待发送端报文，岂不是拜拜浪费资源了。

**TCP的流量控制**

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

如何实现流量控制：使用滑动窗口

**拥塞控制**

![](https://gitee.com/coderth/blogimage/raw/master/img/20210418214121.png)


**三次握手**
![](https://gitee.com/coderth/blogimage/raw/master/img/20210418214911.png)
三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

第一次握手([SYN], Seq = x)：
客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后客户端进入SYN_SEND状态。

第二次握手([SYN,ACK], Seq = y, ACK = x + 1)：
服务器返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK = x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq = y, 表示让客户端确认是否能收到。发送完成后服务端进入SYN_RCVD状态。

第三次握手([ACK], ACK = y + 1)：
客户端再次发送确认包(ACK),ACK = y + 1, 表示确认收到服务器的包（服务端发来的Seq值 + 1）。客户端发送完毕后，进入ESTABLISHED状态，服务端接收到这个包，也进入ESTABLISHED状态, TCP握手结束。
**四次挥手**
![](https://gitee.com/coderth/blogimage/raw/master/img/20210418215030.png)

TCP连接的断开需要发送四个包，所以称为四次挥手。

第一次挥手（[FIN], Seq = x）
客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，客户端进入FIN_WAIT_1状态。

第二次挥手 ([ACK], ACK = x + 1)
服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后，服务端进入CLOSE_WAIT状态，客户端收到这个包后，进入FIN_WAIT_2，等待服务器关闭连接。

第三次挥手 ([FIN], Seq = y)
服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了。发送完成后，服务端进入LAST_ACK状态，等待客户端确认。

第四次挥手 ([ACK], ACK = y + 1)
客户端接收到服务端的关闭请求，再发送ACK标记的确认包，进入TIME_WAIT状态，等待服务端可能请求重传的ACK包。
服务端接收到ACK包后，关闭连接，进入CLOSED状态。
客户端在等待固定时间(两个最大段生命周期)后，没有接收到服务的ACK包，认为服务器已关闭连接，自己也关闭连接，进入CLOSED状态。

**2MSL的作用**

防止最后一次握手ACK丢失，在发送最后一次ACK信息后将会启动一个定时器，2MSL过后将会触发重传机制

**大量close_wait的原因**

客户端因为某种原因先于服务端发出了FIN信号，就会导致服务端被动关闭，若服务端不主动关闭socket发FIN给Client，此时服务端Socket会处于CLOSE_WAIT状态（而不是LAST_ACK状态）。通常来说，一个CLOSE_WAIT会维持至少2个小时的时间（系统默认超时时间的是7200秒，也就是2小时）。如果服务端程序因某个原因导致系统造成一堆CLOSE_WAIT消耗资源，那么通常是等不到释放那一刻，系统就已崩溃。

**DDOS攻击**

又称半连接攻击：指的是再再第二次握手后不返回ACK信息，系统会维护大量的半连接，造成系统资源的浪费